---
interface Props {
	src: string;
	title?: string;
	description?: string;
	width?: string;
	height?: string;
	autoRotate?: boolean;
	backgroundColor?: string;
}

const { 
	src,
	title = "",
	description = "",
	width = "100%",
	height = "500px",
	autoRotate = true,
	backgroundColor = "#1a1a1a"
} = Astro.props;

const viewerId = `three-${Math.random().toString(36).substr(2, 9)}`;
---

<div class="three-container">
	{title && <h3 class="viewer-title">{title}</h3>}
	{description && <p class="viewer-description">{description}</p>}
	<div 
		class="three-viewer" 
		id={viewerId}
		data-src={src}
		data-autorotate={autoRotate.toString()}
		data-bgcolor={backgroundColor}
		style={`width: ${width}; height: ${height};`}
	>
		<div class="loading-state">
			<div class="spinner"></div>
			<span class="loading-text">Cargando modelo 3D...</span>
		</div>
		<div class="error-state" style="display: none;">
			<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="2">
				<circle cx="12" cy="12" r="10"/>
				<path d="M12 8v4M12 16h.01"/>
			</svg>
			<span class="error-text">Error al cargar el modelo</span>
		</div>
	</div>
	<p class="viewer-hint">Arrastra para rotar · Scroll para zoom · Click derecho para mover</p>
</div>

<style>
	.three-container {
		width: 100%;
		margin-bottom: var(--spacing-xl);
	}

	.viewer-title {
		font-size: 1.25rem;
		font-weight: 600;
		color: var(--color-text);
		margin-bottom: var(--spacing-sm);
	}

	.viewer-description {
		font-size: 0.875rem;
		color: var(--color-text-muted);
		margin-bottom: var(--spacing-md);
	}

	.three-viewer {
		background: var(--color-surface);
		border: 1px solid var(--color-border);
		border-radius: var(--radius-lg);
		overflow: hidden;
		position: relative;
	}

	.three-viewer canvas {
		display: block;
		width: 100% !important;
		height: 100% !important;
	}

	.loading-state,
	.error-state {
		position: absolute;
		inset: 0;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		gap: var(--spacing-md);
		color: var(--color-text-muted);
		font-size: 0.875rem;
		background: var(--color-surface);
		z-index: 10;
	}

	.three-viewer.loaded .loading-state {
		display: none;
	}

	.three-viewer.error .loading-state {
		display: none;
	}

	.three-viewer.error .error-state {
		display: flex !important;
	}

	.error-text {
		color: #ef4444;
	}

	.viewer-hint {
		font-size: 0.75rem;
		color: var(--color-text-muted);
		text-align: center;
		margin-top: var(--spacing-sm);
	}

	.spinner {
		width: 32px;
		height: 32px;
		border: 3px solid var(--color-border);
		border-top-color: #2563eb;
		border-radius: 50%;
		animation: spin 1s linear infinite;
	}

	@keyframes spin {
		to {
			transform: rotate(360deg);
		}
	}
</style>

<script type="importmap">
{
	"imports": {
		"three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
		"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
	}
}
</script>

<script type="module">
	import * as THREE from 'three';
	import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

	function initViewer(container) {
		const src = container.dataset.src;
		const autoRotate = container.dataset.autorotate === 'true';
		const bgColor = container.dataset.bgcolor || '#1a1a1a';
		
		if (!src) return;

		const width = container.clientWidth;
		const height = container.clientHeight;

		// Escena
		const scene = new THREE.Scene();
		scene.background = new THREE.Color(bgColor);

		// Cámara
		const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
		camera.position.set(0, 1.5, 3);

		// Renderer
		const renderer = new THREE.WebGLRenderer({ 
			antialias: true,
			alpha: true
		});
		renderer.setSize(width, height);
		renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;
		renderer.outputColorSpace = THREE.SRGBColorSpace;
		renderer.toneMapping = THREE.ACESFilmicToneMapping;
		renderer.toneMappingExposure = 1;
		
		container.appendChild(renderer.domElement);

		// Controles
		const controls = new OrbitControls(camera, renderer.domElement);
		controls.enableDamping = true;
		controls.dampingFactor = 0.05;
		controls.autoRotate = autoRotate;
		controls.autoRotateSpeed = 2;
		controls.minDistance = 1;
		controls.maxDistance = 10;
		controls.target.set(0, 1, 0);

		// Iluminación para personajes
		// Luz ambiental suave
		const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
		scene.add(ambientLight);

		// Luz principal (key light)
		const keyLight = new THREE.DirectionalLight(0xffffff, 1);
		keyLight.position.set(5, 5, 5);
		keyLight.castShadow = true;
		keyLight.shadow.mapSize.width = 2048;
		keyLight.shadow.mapSize.height = 2048;
		scene.add(keyLight);

		// Luz de relleno (fill light)
		const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
		fillLight.position.set(-5, 3, -5);
		scene.add(fillLight);

		// Luz de borde (rim light)
		const rimLight = new THREE.DirectionalLight(0xffffaa, 0.4);
		rimLight.position.set(0, 5, -5);
		scene.add(rimLight);

		// Luz desde abajo suave
		const bottomLight = new THREE.HemisphereLight(0x444444, 0x222222, 0.3);
		scene.add(bottomLight);

		// Cargar modelo GLB
		const loader = new GLTFLoader();
		const absoluteSrc = new URL(src, window.location.origin).href;
		
		console.log('Three.js: Cargando modelo desde:', absoluteSrc);

		// Primero verificar que el archivo sea accesible
		fetch(absoluteSrc)
			.then(response => {
				if (!response.ok) {
					throw new Error(`HTTP ${response.status}`);
				}
				console.log('Three.js: Archivo accesible, Content-Type:', response.headers.get('content-type'));
				return response.arrayBuffer();
			})
			.then(arrayBuffer => {
				console.log('Three.js: ArrayBuffer size:', arrayBuffer.byteLength);
				
				// Verificar header completo de GLB
				const headerView = new DataView(arrayBuffer);
				const magic = String.fromCharCode(
					headerView.getUint8(0),
					headerView.getUint8(1),
					headerView.getUint8(2),
					headerView.getUint8(3)
				);
				const version = headerView.getUint32(4, true); // little-endian
				const length = headerView.getUint32(8, true);
				
				console.log('Three.js: Magic:', magic);
				console.log('Three.js: Version:', version);
				console.log('Three.js: Declared length:', length);
				
				// Verificar primer chunk
				if (arrayBuffer.byteLength >= 20) {
					const chunk0Length = headerView.getUint32(12, true);
					const chunk0Type = headerView.getUint32(16, true);
					console.log('Three.js: Chunk 0 length:', chunk0Length);
					console.log('Three.js: Chunk 0 type:', chunk0Type, chunk0Type === 0x4E4F534A ? '(JSON)' : chunk0Type === 0x004E4942 ? '(BIN)' : '(unknown)');
				}
				
				if (magic !== 'glTF') {
					throw new Error('No es un archivo GLB válido (magic: ' + magic + ')');
				}
				
				if (version !== 2) {
					throw new Error('GLB version ' + version + ' no soportada. Se requiere version 2.');
				}
				
				// Parsear directamente el ArrayBuffer
				loader.parse(arrayBuffer, '', 
					(gltf) => {
						onModelLoaded(gltf);
					},
					(error) => {
						console.error('Three.js: Error parseando:', error);
						container.classList.add('error');
					}
				);
			})
			.catch(error => {
				console.error('Three.js: Error fetch:', error);
				container.classList.add('error');
			});

		function onModelLoaded(gltf) {
			const model = gltf.scene;
				
				// Calcular bounding box para centrar y escalar
				const box = new THREE.Box3().setFromObject(model);
				const size = box.getSize(new THREE.Vector3());
				const center = box.getCenter(new THREE.Vector3());

				// Centrar el modelo
				model.position.sub(center);
				model.position.y += size.y / 2;

				// Escalar si es muy grande o muy pequeño
				const maxDim = Math.max(size.x, size.y, size.z);
				if (maxDim > 3 || maxDim < 0.5) {
					const scale = 2 / maxDim;
					model.scale.setScalar(scale);
				}

				// Habilitar sombras
				model.traverse((child) => {
					if (child.isMesh) {
						child.castShadow = true;
						child.receiveShadow = true;
					}
				});

				scene.add(model);

				// Ajustar cámara al modelo
				const newBox = new THREE.Box3().setFromObject(model);
				const newSize = newBox.getSize(new THREE.Vector3());
				const newCenter = newBox.getCenter(new THREE.Vector3());
				
				controls.target.copy(newCenter);
				camera.position.set(
					newCenter.x + newSize.x * 1.5,
					newCenter.y + newSize.y * 0.5,
					newCenter.z + newSize.z * 1.5
				);
				controls.update();

				// Marcar como cargado
				container.classList.add('loaded');
				console.log('Three.js: Modelo cargado exitosamente');

				// Animaciones si existen
				if (gltf.animations && gltf.animations.length > 0) {
					const mixer = new THREE.AnimationMixer(model);
					const action = mixer.clipAction(gltf.animations[0]);
					action.play();
					
					// Guardar mixer para el loop
					container._mixer = mixer;
					container._clock = new THREE.Clock();
				}
		}

		// Loop de animación
		function animate() {
			requestAnimationFrame(animate);
			
			// Actualizar animaciones del modelo
			if (container._mixer && container._clock) {
				container._mixer.update(container._clock.getDelta());
			}
			
			controls.update();
			renderer.render(scene, camera);
		}
		animate();

		// Manejar resize
		const resizeObserver = new ResizeObserver((entries) => {
			for (const entry of entries) {
				const { width, height } = entry.contentRect;
				if (width > 0 && height > 0) {
					camera.aspect = width / height;
					camera.updateProjectionMatrix();
					renderer.setSize(width, height);
				}
			}
		});
		resizeObserver.observe(container);
	}

	// Inicializar todos los viewers
	function initAllViewers() {
		const viewers = document.querySelectorAll('.three-viewer');
		viewers.forEach(initViewer);
	}

	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initAllViewers);
	} else {
		initAllViewers();
	}
</script>
